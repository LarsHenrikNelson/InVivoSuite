import numpy as np
from numba import njit
from scipy import integrate
from scipy.spatial import distance

from .basis import gauss_2D, gauss_lim_2D, step_2D
from .utils import distribute_srcs_2D


def estimate_at(xmax, xmin, ymax, ymin, gdx, gdy):
    """Defines locations where the estimation is wanted
    Defines:
    n_estm = estm_x.size
    ngx, ngy = estm_x.shape
    estm_x, estm_y : Locations at which CSD is requested.
    Parameters
    ----------
    None
    """
    nx = (xmax - xmin) / gdx
    ny = (ymax - ymin) / gdy
    estm_x, estm_y = np.mgrid[
        xmin : xmax : complex(0, nx),
        ymin : ymax : complex(0, ny),
    ]
    n_estm = estm_x.size
    ngx, ngy = estm_x.shape
    return estm_x, estm_y, n_estm, ngx, ngy


@njit()
def place_basis(src_type, estm_x, estm_y, n_src_init, ext_x, ext_y, R_init):
    """Places basis sources of the defined type.
    Checks if a given source_type is defined, if so then defines it
    basis, This function gives locations of the basis sources,
    Defines
    source_type : basis_fuctions.basis_2D.keys()
    R based on R_init
    dist_max as maximum distance between electrode and basis
    nsx, nsy = src_x.shape
    src_x, src_y : Locations at which basis sources are placed.
    Parameters
    ----------
    None
    """
    if src_type == "gauss":
        gauss_2D()
    elif src_type == "gauss_lim":
        gauss_lim_2D()
    elif src_type == "step":
        step_2D()
    else:
        raise ValueError("src_type needs to be gauss, step or gauss_lim")

    (src_x, src_y, R) = distribute_srcs_2D(
        estm_x, estm_y, n_src_init, ext_x, ext_y, R_init
    )
    n_src = src_x.size
    nsx, nsy = src_x.shape
    return src_x, src_y, R, n_src, nsx, nsy


def create_src_dist_tables(self):
    """Creates distance tables between sources, electrode and estm points
    Parameters
    ----------
    None
    """
    src_loc = np.array((self.src_x.ravel(), self.src_y.ravel()))
    est_loc = np.array((self.estm_x.ravel(), self.estm_y.ravel()))
    self.src_ele_dists = distance.cdist(src_loc.T, self.ele_pos, "euclidean")
    self.src_estm_dists = distance.cdist(src_loc.T, est_loc.T, "euclidean")
    self.dist_max = (
        np.max(np.max(self.src_ele_dists), np.max(self.src_estm_dists)) + self.R
    )


def forward_model(self, x, R, h, sigma, src_type):
    """FWD model functions
    Evaluates potential at point (x,0) by a basis source located at (0,0)
    Eq 22 kCSD by Jan,2012
    Parameters
    ----------
    x : float
    R : float
    h : float
    sigma : float
    src_type : basis_2D.key
    Returns
    -------
    pot : float
        value of potential at specified distance from the source
    """
    pot, err = integrate.dblquad(
        self.int_pot_2D, -R, R, lambda x: -R, lambda x: R, args=(x, R, h, src_type)
    )
    pot *= 1.0 / (2.0 * np.pi * sigma)  # Potential basis functions bi_x_y
    return pot


@njit()
def int_pot_2D(xp, yp, x, R, h, basis_func):
    """FWD model function.
    Returns contribution of a point xp,yp, belonging to a basis source
    support centered at (0,0) to the potential measured at (x,0),
    integrated over xp,yp gives the potential generated by a
    basis source element centered at (0,0) at point (x,0)
    Parameters
    ----------
    xp, yp : floats or np.arrays
        point or set of points where function should be calculated
    x :  float
        position at which potential is being measured
    R : float
        The size of the basis function
    h : float
        thickness of slice
    basis_func : method
        Fuction of the basis source
    Returns
    -------
    pot : float
    """
    y = ((x - xp) ** 2 + yp**2) ** (0.5)
    if y < 0.00001:
        y = 0.00001
    dist = np.sqrt(xp**2 + yp**2)
    pot = np.arcsinh(h / y) * basis_func(dist, R)
    return pot
